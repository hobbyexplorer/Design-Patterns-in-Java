package model;

import java.awt.Color;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Image;
import java.awt.Toolkit;
import java.awt.geom.AffineTransform;
import java.awt.geom.Point2D;
import java.awt.image.AffineTransformOp;
import java.awt.image.BufferedImage;
import java.awt.image.BufferedImageOp;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;

import org.w3c.dom.Document;
import org.w3c.dom.Element;

public class GameObject1 {

	//x and y position of the object
	private int x;
	private int y;
	
	//height and width of the object, wich will be initialized by the sprite to which it belongs,
	//and is similar to the height and width of the sprite.
	private int height;
	private int width;
	
	private int deltaX;
	private int deltaY;
	
	private Shape shape;
	
	//Color of the object.
	private Color color;
	
	//objectId is generated by the sprite class to manage an array-list of the objects
	private int objectId;
	
	//the image of the object.
	private Image image;
	
	public GameObject1(int objectId, int x, int y, int height, int width, int deltaX, int deltaY){
		this.objectId = objectId;
		this.height = height;
		this.width = width;
		this.x = x;
		this.y = y;
		this.deltaX = deltaX;
		this.deltaY = deltaY;
	}

	public void draw(Graphics g)
	{
		 
		this.shape.draw(g, this.getX(), this.getY(), this.getObjectWidth(), this.getObjectHeight(), this.getColor(), this.getImage(),0, false,false,false,1,1);
		
	}
	
	public void moveObject()
	{
		this.moveHorizontal();
		this.moveVertical();
	}
	
	public void moveHorizontal(){
		this.x += this.deltaX;
	}
	
	public void moveVertical(){
		this.y += this.deltaY;
	}
	
	public void moveHorizontal(int by){
		this.x += by;
	}
	
	public void moveVertical(int by){
		this.y += by;
	}
	
	/*
	 * Contracts the object by percent
	 * @param contractBy: Percent by which you want to reduce the object by
	 */
	public void contract(int contracBy){
		double reduceByScale = (double)contracBy/100;
		double resultScale = 1.0 - reduceByScale;
		double displaceXBy = (double)this.getX()*(reduceByScale/2);
		double displaceYBy = (double)this.getY()*(reduceByScale/2);
		
		moveHorizontal((int)Math.round(displaceXBy));
		moveVertical((int)Math.round(displaceYBy));
		this.setObjectHeight((int)Math.round((double)this.getObjectHeight() * resultScale));
		this.setObjectWidth((int)Math.round((double)this.getObjectWidth() * resultScale));
	}
	
	public void expand(int contracBy){
		double enlargeByScale = (double)contracBy/100;
		double resultScale = 1.0 + enlargeByScale;
		double displaceXBy = (double)this.getX()*(enlargeByScale/2);
		double displaceYBy = (double)this.getY()*(enlargeByScale/2);
		
		moveHorizontal((int)Math.round(-1.0 * displaceXBy));
		moveVertical((int)Math.round(-1.0 * displaceYBy));
		this.setObjectHeight((int)Math.round((double)this.getObjectHeight() * resultScale));
		this.setObjectWidth((int)Math.round((double)this.getObjectWidth() * resultScale));
	}
	
	
	private AffineTransform findTranslation(AffineTransform at, BufferedImage bi) {
		    Point2D p2din, p2dout;
		    p2din = new Point2D.Double(0.0, 0.0);
		    p2dout = at.transform(p2din, null);
		    double ytrans = p2dout.getY();
		    p2din = new Point2D.Double(0, bi.getHeight());
		    p2dout = at.transform(p2din, null);
		    double xtrans = p2dout.getX();
		    AffineTransform tat = new AffineTransform();
		    tat.translate(-xtrans, -ytrans);
		    return tat;
		  }

	
	public void rotate(int degrees){
		double radian = Math.toRadians(degrees);
		BufferedImage DBImage = null, SBImage = new BufferedImage(this.getImage().getWidth(null), this.getImage().getHeight(null), BufferedImage.TYPE_INT_ARGB);
		AffineTransform affineTransform = new AffineTransform();
		Graphics2D g = (Graphics2D)SBImage.getGraphics();
		g.drawImage(this.getImage(), 0, 0, null);
		
		affineTransform.rotate(radian, SBImage.getWidth()/2.0, SBImage.getHeight()/2);
		
		AffineTransform translationTransform;
		translationTransform = findTranslation(affineTransform, SBImage);
		affineTransform.preConcatenate(translationTransform);
		
		BufferedImageOp bop;
		bop = new AffineTransformOp(affineTransform, AffineTransformOp.TYPE_BILINEAR);
		DBImage = bop.filter(SBImage, null);
		this.setImage(Toolkit.getDefaultToolkit().createImage(DBImage.getSource()));
		this.setObjectHeight(this.getImage().getHeight(null));
		this.setObjectWidth(this.getImage().getWidth(null));
	}
	
	
	
	public void setX(int x)
	{
		this.x = x;
	}

	public int getX()
	{
		return x;
	}

	public void setY(int y)
	{
		this.y = y;
	}

	public int getY()
	{
		return y;
	}
	
	public void setObjectHeight(int height)
	{
		this.height = height;
	}

	public int getObjectHeight()
	{
		return height;
	}
	
	public void setObjectWidth(int width)
	{
		this.width = width;
	}
	
	public int getObjectWidth()
	{
		return width;
	}
	
	public void setColor( Color color)
	{
		this.color = color;
	}

	public Color getColor()
	{
		return color;
	}

	public void setObjectId(int objectId)
	{
		this.objectId = objectId;
	}

	public int getObjectId()
	{
		return objectId;
	}

	public void setImage(Image image)
	{
		this.image = image;
	}

	public Image getImage()
	{
		return image;
	}

	public void setDeltaX(int deltaX)
	{
		this.deltaX = deltaX;
	}

	public int getDeltaX()
	{
		return deltaX;
	}

	public void setDeltaY(int deltaY)
	{
		this.deltaY = deltaY;
	}

	public int getDeltaY()
	{
		return deltaY;
	}
	
	
	
}
